<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>denverapi.cipher API documentation</title>
<meta name="description" content="This is very useful module in-case of cipher encrypting and decrypting of data.
This contains many cipher methods. The Best of all is the vigenere …" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>denverapi.cipher</code></h1>
</header>
<section id="section-intro">
<p>This is very useful module in-case of cipher encrypting and decrypting of data.
This contains many cipher methods. The Best of all is the vigenere cipher.</p>
<p>The Source code is taken from the book "Cracking Codes with Python". Although
hacking methods for all the ciphers are not created, the hackers can still
break the code by using different techniques, so it is recommended you should
go for crypt2.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
This is very useful module in-case of cipher encrypting and decrypting of data.
This contains many cipher methods. The Best of all is the vigenere cipher.

The Source code is taken from the book &#34;Cracking Codes with Python&#34;. Although
hacking methods for all the ciphers are not created, the hackers can still
break the code by using different techniques, so it is recommended you should
go for crypt2.
&#34;&#34;&#34;

__version__ = &#34;2021.2.24&#34;
__author__ = &#34;Xcodz&#34;

import math


def _crypto_math_gcd(a, b):
    while a != 0:
        a, b = b % a, a
    return b


def _crypto_math_find_mod_inverse(a, m):
    if _crypto_math_gcd(a, m) != 1:
        return None
    u1, u2, u3 = 1, 0, a
    v1, v2, v3 = 0, 1, m
    while v3 != 0:
        q = u3 // v3
        v1, v2, v3, u1, u2, u3 = (
            (u1 - q * v1),
            (u2 - q * v2),
            (u3 - q * v3),
            v1,
            v2,
            v3,
        )
    return u1 % m


_cvig_l = &#34;ABCDEFGHIJKLMNOPQRSTUVWXYZ&#34;


def _cvig_translate_message(key, message, mode):
    key_list = _cvig_l
    t = []
    ki = 0
    for x in message:
        n = key_list.find(x.upper())
        if n != -1:
            if mode == &#34;e&#34;:
                n += key_list.find(key[ki])
            elif mode == &#34;d&#34;:
                n -= key_list.find(key[ki])
            n %= len(key_list)
            if x.isupper():
                t.append(key_list[n])
            elif x.islower():
                t.append(key_list[n].lower())
            ki += 1
            if ki == len(key):
                ki = 0
        else:
            t.append(x)
    return &#34;&#34;.join(t)


_csub_l = &#34;ABCDEFGHIJKLMNOPQRSTUVWXYZ&#34;


def _csub_key_is_valid(key):
    key_list = list(key)
    letters_list = list(_csub_l)
    key_list.sort()
    return key_list == letters_list


def _csub_translate_message(key: str, message: str, mode):
    t = &#34;&#34;
    ca = _csub_l
    cb = key
    if mode == &#34;d&#34;:
        ca, cb = cb, ca
    for x in message:
        if x.upper() in ca:
            si = ca.find(x.upper())
            if x.isupper():
                t += cb[si].upper()
            else:
                t += cb[si].lower()
        else:
            t += x
    return t


def _caffine_get_key_parts(key):
    a = &#34;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz1234567890 !?.&#34;
    key_a = key // len(a)
    key_b = key % len(a)
    return key_a, key_b


def _caffine_check_keys(key_a, key_b):
    a = &#34;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz1234567890 !?.&#34;
    if key_a &lt; 0 or key_b &lt; 0 or key_b &gt; len(a) - 1:
        return False
    if _crypto_math_gcd(key_a, len(a)) != 1:
        return False
    return True


class morse:
    table = {
        &#34;.-&#34;: &#34;A&#34;,
        &#34;-...&#34;: &#34;B&#34;,
        &#34;-.-.&#34;: &#34;C&#34;,
        &#34;-..&#34;: &#34;D&#34;,
        &#34;.&#34;: &#34;E&#34;,
        &#34;..-.&#34;: &#34;F&#34;,
        &#34;--.&#34;: &#34;G&#34;,
        &#34;....&#34;: &#34;H&#34;,
        &#34;..&#34;: &#34;I&#34;,
        &#34;.---&#34;: &#34;J&#34;,
        &#34;-.-&#34;: &#34;K&#34;,
        &#34;.-..&#34;: &#34;L&#34;,
        &#34;--&#34;: &#34;M&#34;,
        &#34;-.&#34;: &#34;N&#34;,
        &#34;---&#34;: &#34;O&#34;,
        &#34;.--.&#34;: &#34;P&#34;,
        &#34;--.-&#34;: &#34;Q&#34;,
        &#34;.-.&#34;: &#34;R&#34;,
        &#34;...&#34;: &#34;S&#34;,
        &#34;-&#34;: &#34;T&#34;,
        &#34;..-&#34;: &#34;U&#34;,
        &#34;...-&#34;: &#34;V&#34;,
        &#34;.--&#34;: &#34;W&#34;,
        &#34;-..-&#34;: &#34;X&#34;,
        &#34;-.--&#34;: &#34;Y&#34;,
        &#34;--..&#34;: &#34;Z&#34;,
        &#34;.----&#34;: &#34;1&#34;,
        &#34;..---&#34;: &#34;2&#34;,
        &#34;...--&#34;: &#34;3&#34;,
        &#34;....-&#34;: &#34;4&#34;,
        &#34;.....&#34;: &#34;5&#34;,
        &#34;-....&#34;: &#34;6&#34;,
        &#34;--...&#34;: &#34;7&#34;,
        &#34;---..&#34;: &#34;8&#34;,
        &#34;----.&#34;: &#34;9&#34;,
        &#34;-----&#34;: &#34;0&#34;,
    }

    @staticmethod
    def encode(st: str):
        &#34;&#34;&#34;MORSE CODE ENCODER

        A &#39; &#39; MEANS PARTITION BETWEEN LETTERS
        A &#39;/&#39; MEANS PARTITION BETWEEN WORDS&#34;&#34;&#34;
        t = &#34;&#34;
        tb = {v: k for k, v in morse.table.items()}
        s = list(st.upper())
        for x in s:
            if x not in tb.keys() and x != &#34; &#34;:
                s.remove(x)
        w = []
        for x in s:
            if x == &#34; &#34;:
                t += &#34; &#34;.join(w) + &#34;/&#34;
                w = []
            else:
                w.append(tb[x])
        t += &#34; &#34;.join(w)
        return t

    @staticmethod
    def decode(s: str):
        tb = morse.table.copy()
        d = [x.split() for x in s.split(&#34;/&#34;)]
        t = &#34;&#34;
        for x in d:
            for y in x:
                t += tb[y]
            t += &#34; &#34;
        return t[0:-1]


class basic:
    @staticmethod
    def encode(b: bytes = b&#34;&#34;):
        &#34;&#34;&#34;Encode Bytes to String&#34;&#34;&#34;
        d = [hex(x)[2:] for x in list(b)]
        for x in range(len(d)):
            if len(d[x]) == 1:
                d[x] = &#34;0&#34; + d[x]
        return &#34;&#34;.join(d)

    @staticmethod
    def decode(s: str):
        return bytes([int(&#34;0x&#34; + s[x] + s[x + 1], 0) for x in range(0, len(s), 2)])


class reverse_cipher:
    @staticmethod
    def crypt(s: str):
        return &#34;&#34;.join(reversed(s))


class caesar_cipher:
    @staticmethod
    def encrypt(s: str, k: int):
        &#34;&#34;&#34;Encrypts with Caesar cipher&#34;&#34;&#34;
        a = &#34;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz1234567890 !?.&#34;
        t = &#34;&#34;
        for x in s:
            if x in a:
                si = a.find(x)
                ti = si + k
                if ti &gt;= len(a):
                    ti -= len(a)
                elif ti &lt; 0:
                    ti += len(a)
                t += a[ti]
            else:
                t += x
        return t

    @staticmethod
    def decrypt(s: str, k: int):
        &#34;&#34;&#34;Decrypts with caesar cipher&#34;&#34;&#34;
        a = &#34;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz1234567890 !?.&#34;
        t = &#34;&#34;
        for x in s:
            if x in a:
                si = a.find(x)
                ti = si - k
                if ti &gt;= len(a):
                    ti -= len(a)
                elif ti &lt; 0:
                    ti += len(a)
                t += a[ti]
            else:
                t += x
        return t


class transposition_cipher:
    @staticmethod
    def encrypt(message: str, key: int):
        # Each string in ciphertext represents a column in the grid:
        ciphertext = [&#34;&#34;] * key
        # Loop through each column in ciphertext:
        for column in range(key):
            current_index = column
            # Keep looping until current_index goes past the message length:
            while current_index &lt; len(message):
                # Place the character at current_index in message at the
                # end of the current column in the ciphertext list:
                ciphertext[column] += message[current_index]
                # Move current_index over:
                current_index += key
        # Convert the ciphertext list into a single string value and return it:
        return &#34;&#34;.join(ciphertext)

    @staticmethod
    def decrypt(message: str, key: int):
        num_of_columns = int(math.ceil(len(message) / float(key)))
        num_of_rows = key
        num_of_shaded_boxes = (num_of_columns * num_of_rows) - len(message)
        plaintext = [&#34;&#34;] * num_of_columns
        column = row = 0
        for symbol in message:
            plaintext[column] += symbol
            column += 1
            if (column == num_of_columns) or (
                column == num_of_columns - 1
                and row &gt;= num_of_rows - num_of_shaded_boxes
            ):
                column = 0
                row += 1
        return &#34;&#34;.join(plaintext)


class affine_cipher:
    @staticmethod
    def encrypt(message: str, key: int):
        a = &#34;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz1234567890 !?.&#34;
        ka, kb = _caffine_get_key_parts(key)
        if _caffine_check_keys(ka, kb):
            ct = &#34;&#34;
            for x in message:
                if x in a:
                    si = a.find(x)
                    ct += a[(si * ka + kb) % len(a)]
                else:
                    ct += x
            return ct
        else:
            return message

    @staticmethod
    def decrypt(message: str, key: int):
        a = &#34;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz1234567890 !?.&#34;
        ka, kb = _caffine_get_key_parts(key)
        if _caffine_check_keys(ka, kb):
            pt = &#34;&#34;
            mioka = _crypto_math_find_mod_inverse(ka, len(a))
            for x in message:
                if x in a:
                    si = a.find(x)
                    pt += a[(si - kb) * mioka % len(a)]
                else:
                    pt += x
            return pt
        else:
            return message


class substitution_cipher:
    @staticmethod
    def encrypt(m: str, key: str):
        return _csub_translate_message(key, m, &#34;e&#34;)

    @staticmethod
    def decrypt(m: str, key: str):
        return _csub_translate_message(key, m, &#34;d&#34;)


class vigenere_cipher:
    @staticmethod
    def encrypt(m: str, k: str):
        return _cvig_translate_message(k, m, &#34;e&#34;)

    @staticmethod
    def decrypt(m: str, k: str):
        return _cvig_translate_message(k, m, &#34;d&#34;)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="denverapi.cipher.affine_cipher"><code class="flex name class">
<span>class <span class="ident">affine_cipher</span></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class affine_cipher:
    @staticmethod
    def encrypt(message: str, key: int):
        a = &#34;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz1234567890 !?.&#34;
        ka, kb = _caffine_get_key_parts(key)
        if _caffine_check_keys(ka, kb):
            ct = &#34;&#34;
            for x in message:
                if x in a:
                    si = a.find(x)
                    ct += a[(si * ka + kb) % len(a)]
                else:
                    ct += x
            return ct
        else:
            return message

    @staticmethod
    def decrypt(message: str, key: int):
        a = &#34;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz1234567890 !?.&#34;
        ka, kb = _caffine_get_key_parts(key)
        if _caffine_check_keys(ka, kb):
            pt = &#34;&#34;
            mioka = _crypto_math_find_mod_inverse(ka, len(a))
            for x in message:
                if x in a:
                    si = a.find(x)
                    pt += a[(si - kb) * mioka % len(a)]
                else:
                    pt += x
            return pt
        else:
            return message</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="denverapi.cipher.affine_cipher.decrypt"><code class="name flex">
<span>def <span class="ident">decrypt</span></span>(<span>message: str, key: int)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def decrypt(message: str, key: int):
    a = &#34;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz1234567890 !?.&#34;
    ka, kb = _caffine_get_key_parts(key)
    if _caffine_check_keys(ka, kb):
        pt = &#34;&#34;
        mioka = _crypto_math_find_mod_inverse(ka, len(a))
        for x in message:
            if x in a:
                si = a.find(x)
                pt += a[(si - kb) * mioka % len(a)]
            else:
                pt += x
        return pt
    else:
        return message</code></pre>
</details>
</dd>
<dt id="denverapi.cipher.affine_cipher.encrypt"><code class="name flex">
<span>def <span class="ident">encrypt</span></span>(<span>message: str, key: int)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def encrypt(message: str, key: int):
    a = &#34;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz1234567890 !?.&#34;
    ka, kb = _caffine_get_key_parts(key)
    if _caffine_check_keys(ka, kb):
        ct = &#34;&#34;
        for x in message:
            if x in a:
                si = a.find(x)
                ct += a[(si * ka + kb) % len(a)]
            else:
                ct += x
        return ct
    else:
        return message</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="denverapi.cipher.basic"><code class="flex name class">
<span>class <span class="ident">basic</span></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class basic:
    @staticmethod
    def encode(b: bytes = b&#34;&#34;):
        &#34;&#34;&#34;Encode Bytes to String&#34;&#34;&#34;
        d = [hex(x)[2:] for x in list(b)]
        for x in range(len(d)):
            if len(d[x]) == 1:
                d[x] = &#34;0&#34; + d[x]
        return &#34;&#34;.join(d)

    @staticmethod
    def decode(s: str):
        return bytes([int(&#34;0x&#34; + s[x] + s[x + 1], 0) for x in range(0, len(s), 2)])</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="denverapi.cipher.basic.decode"><code class="name flex">
<span>def <span class="ident">decode</span></span>(<span>s: str)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def decode(s: str):
    return bytes([int(&#34;0x&#34; + s[x] + s[x + 1], 0) for x in range(0, len(s), 2)])</code></pre>
</details>
</dd>
<dt id="denverapi.cipher.basic.encode"><code class="name flex">
<span>def <span class="ident">encode</span></span>(<span>b: bytes = b'')</span>
</code></dt>
<dd>
<div class="desc"><p>Encode Bytes to String</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def encode(b: bytes = b&#34;&#34;):
    &#34;&#34;&#34;Encode Bytes to String&#34;&#34;&#34;
    d = [hex(x)[2:] for x in list(b)]
    for x in range(len(d)):
        if len(d[x]) == 1:
            d[x] = &#34;0&#34; + d[x]
    return &#34;&#34;.join(d)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="denverapi.cipher.caesar_cipher"><code class="flex name class">
<span>class <span class="ident">caesar_cipher</span></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class caesar_cipher:
    @staticmethod
    def encrypt(s: str, k: int):
        &#34;&#34;&#34;Encrypts with Caesar cipher&#34;&#34;&#34;
        a = &#34;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz1234567890 !?.&#34;
        t = &#34;&#34;
        for x in s:
            if x in a:
                si = a.find(x)
                ti = si + k
                if ti &gt;= len(a):
                    ti -= len(a)
                elif ti &lt; 0:
                    ti += len(a)
                t += a[ti]
            else:
                t += x
        return t

    @staticmethod
    def decrypt(s: str, k: int):
        &#34;&#34;&#34;Decrypts with caesar cipher&#34;&#34;&#34;
        a = &#34;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz1234567890 !?.&#34;
        t = &#34;&#34;
        for x in s:
            if x in a:
                si = a.find(x)
                ti = si - k
                if ti &gt;= len(a):
                    ti -= len(a)
                elif ti &lt; 0:
                    ti += len(a)
                t += a[ti]
            else:
                t += x
        return t</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="denverapi.cipher.caesar_cipher.decrypt"><code class="name flex">
<span>def <span class="ident">decrypt</span></span>(<span>s: str, k: int)</span>
</code></dt>
<dd>
<div class="desc"><p>Decrypts with caesar cipher</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def decrypt(s: str, k: int):
    &#34;&#34;&#34;Decrypts with caesar cipher&#34;&#34;&#34;
    a = &#34;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz1234567890 !?.&#34;
    t = &#34;&#34;
    for x in s:
        if x in a:
            si = a.find(x)
            ti = si - k
            if ti &gt;= len(a):
                ti -= len(a)
            elif ti &lt; 0:
                ti += len(a)
            t += a[ti]
        else:
            t += x
    return t</code></pre>
</details>
</dd>
<dt id="denverapi.cipher.caesar_cipher.encrypt"><code class="name flex">
<span>def <span class="ident">encrypt</span></span>(<span>s: str, k: int)</span>
</code></dt>
<dd>
<div class="desc"><p>Encrypts with Caesar cipher</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def encrypt(s: str, k: int):
    &#34;&#34;&#34;Encrypts with Caesar cipher&#34;&#34;&#34;
    a = &#34;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz1234567890 !?.&#34;
    t = &#34;&#34;
    for x in s:
        if x in a:
            si = a.find(x)
            ti = si + k
            if ti &gt;= len(a):
                ti -= len(a)
            elif ti &lt; 0:
                ti += len(a)
            t += a[ti]
        else:
            t += x
    return t</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="denverapi.cipher.morse"><code class="flex name class">
<span>class <span class="ident">morse</span></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class morse:
    table = {
        &#34;.-&#34;: &#34;A&#34;,
        &#34;-...&#34;: &#34;B&#34;,
        &#34;-.-.&#34;: &#34;C&#34;,
        &#34;-..&#34;: &#34;D&#34;,
        &#34;.&#34;: &#34;E&#34;,
        &#34;..-.&#34;: &#34;F&#34;,
        &#34;--.&#34;: &#34;G&#34;,
        &#34;....&#34;: &#34;H&#34;,
        &#34;..&#34;: &#34;I&#34;,
        &#34;.---&#34;: &#34;J&#34;,
        &#34;-.-&#34;: &#34;K&#34;,
        &#34;.-..&#34;: &#34;L&#34;,
        &#34;--&#34;: &#34;M&#34;,
        &#34;-.&#34;: &#34;N&#34;,
        &#34;---&#34;: &#34;O&#34;,
        &#34;.--.&#34;: &#34;P&#34;,
        &#34;--.-&#34;: &#34;Q&#34;,
        &#34;.-.&#34;: &#34;R&#34;,
        &#34;...&#34;: &#34;S&#34;,
        &#34;-&#34;: &#34;T&#34;,
        &#34;..-&#34;: &#34;U&#34;,
        &#34;...-&#34;: &#34;V&#34;,
        &#34;.--&#34;: &#34;W&#34;,
        &#34;-..-&#34;: &#34;X&#34;,
        &#34;-.--&#34;: &#34;Y&#34;,
        &#34;--..&#34;: &#34;Z&#34;,
        &#34;.----&#34;: &#34;1&#34;,
        &#34;..---&#34;: &#34;2&#34;,
        &#34;...--&#34;: &#34;3&#34;,
        &#34;....-&#34;: &#34;4&#34;,
        &#34;.....&#34;: &#34;5&#34;,
        &#34;-....&#34;: &#34;6&#34;,
        &#34;--...&#34;: &#34;7&#34;,
        &#34;---..&#34;: &#34;8&#34;,
        &#34;----.&#34;: &#34;9&#34;,
        &#34;-----&#34;: &#34;0&#34;,
    }

    @staticmethod
    def encode(st: str):
        &#34;&#34;&#34;MORSE CODE ENCODER

        A &#39; &#39; MEANS PARTITION BETWEEN LETTERS
        A &#39;/&#39; MEANS PARTITION BETWEEN WORDS&#34;&#34;&#34;
        t = &#34;&#34;
        tb = {v: k for k, v in morse.table.items()}
        s = list(st.upper())
        for x in s:
            if x not in tb.keys() and x != &#34; &#34;:
                s.remove(x)
        w = []
        for x in s:
            if x == &#34; &#34;:
                t += &#34; &#34;.join(w) + &#34;/&#34;
                w = []
            else:
                w.append(tb[x])
        t += &#34; &#34;.join(w)
        return t

    @staticmethod
    def decode(s: str):
        tb = morse.table.copy()
        d = [x.split() for x in s.split(&#34;/&#34;)]
        t = &#34;&#34;
        for x in d:
            for y in x:
                t += tb[y]
            t += &#34; &#34;
        return t[0:-1]</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="denverapi.cipher.morse.table"><code class="name">var <span class="ident">table</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="denverapi.cipher.morse.decode"><code class="name flex">
<span>def <span class="ident">decode</span></span>(<span>s: str)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def decode(s: str):
    tb = morse.table.copy()
    d = [x.split() for x in s.split(&#34;/&#34;)]
    t = &#34;&#34;
    for x in d:
        for y in x:
            t += tb[y]
        t += &#34; &#34;
    return t[0:-1]</code></pre>
</details>
</dd>
<dt id="denverapi.cipher.morse.encode"><code class="name flex">
<span>def <span class="ident">encode</span></span>(<span>st: str)</span>
</code></dt>
<dd>
<div class="desc"><p>MORSE CODE ENCODER</p>
<p>A ' ' MEANS PARTITION BETWEEN LETTERS
A '/' MEANS PARTITION BETWEEN WORDS</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def encode(st: str):
    &#34;&#34;&#34;MORSE CODE ENCODER

    A &#39; &#39; MEANS PARTITION BETWEEN LETTERS
    A &#39;/&#39; MEANS PARTITION BETWEEN WORDS&#34;&#34;&#34;
    t = &#34;&#34;
    tb = {v: k for k, v in morse.table.items()}
    s = list(st.upper())
    for x in s:
        if x not in tb.keys() and x != &#34; &#34;:
            s.remove(x)
    w = []
    for x in s:
        if x == &#34; &#34;:
            t += &#34; &#34;.join(w) + &#34;/&#34;
            w = []
        else:
            w.append(tb[x])
    t += &#34; &#34;.join(w)
    return t</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="denverapi.cipher.reverse_cipher"><code class="flex name class">
<span>class <span class="ident">reverse_cipher</span></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class reverse_cipher:
    @staticmethod
    def crypt(s: str):
        return &#34;&#34;.join(reversed(s))</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="denverapi.cipher.reverse_cipher.crypt"><code class="name flex">
<span>def <span class="ident">crypt</span></span>(<span>s: str)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def crypt(s: str):
    return &#34;&#34;.join(reversed(s))</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="denverapi.cipher.substitution_cipher"><code class="flex name class">
<span>class <span class="ident">substitution_cipher</span></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class substitution_cipher:
    @staticmethod
    def encrypt(m: str, key: str):
        return _csub_translate_message(key, m, &#34;e&#34;)

    @staticmethod
    def decrypt(m: str, key: str):
        return _csub_translate_message(key, m, &#34;d&#34;)</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="denverapi.cipher.substitution_cipher.decrypt"><code class="name flex">
<span>def <span class="ident">decrypt</span></span>(<span>m: str, key: str)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def decrypt(m: str, key: str):
    return _csub_translate_message(key, m, &#34;d&#34;)</code></pre>
</details>
</dd>
<dt id="denverapi.cipher.substitution_cipher.encrypt"><code class="name flex">
<span>def <span class="ident">encrypt</span></span>(<span>m: str, key: str)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def encrypt(m: str, key: str):
    return _csub_translate_message(key, m, &#34;e&#34;)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="denverapi.cipher.transposition_cipher"><code class="flex name class">
<span>class <span class="ident">transposition_cipher</span></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class transposition_cipher:
    @staticmethod
    def encrypt(message: str, key: int):
        # Each string in ciphertext represents a column in the grid:
        ciphertext = [&#34;&#34;] * key
        # Loop through each column in ciphertext:
        for column in range(key):
            current_index = column
            # Keep looping until current_index goes past the message length:
            while current_index &lt; len(message):
                # Place the character at current_index in message at the
                # end of the current column in the ciphertext list:
                ciphertext[column] += message[current_index]
                # Move current_index over:
                current_index += key
        # Convert the ciphertext list into a single string value and return it:
        return &#34;&#34;.join(ciphertext)

    @staticmethod
    def decrypt(message: str, key: int):
        num_of_columns = int(math.ceil(len(message) / float(key)))
        num_of_rows = key
        num_of_shaded_boxes = (num_of_columns * num_of_rows) - len(message)
        plaintext = [&#34;&#34;] * num_of_columns
        column = row = 0
        for symbol in message:
            plaintext[column] += symbol
            column += 1
            if (column == num_of_columns) or (
                column == num_of_columns - 1
                and row &gt;= num_of_rows - num_of_shaded_boxes
            ):
                column = 0
                row += 1
        return &#34;&#34;.join(plaintext)</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="denverapi.cipher.transposition_cipher.decrypt"><code class="name flex">
<span>def <span class="ident">decrypt</span></span>(<span>message: str, key: int)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def decrypt(message: str, key: int):
    num_of_columns = int(math.ceil(len(message) / float(key)))
    num_of_rows = key
    num_of_shaded_boxes = (num_of_columns * num_of_rows) - len(message)
    plaintext = [&#34;&#34;] * num_of_columns
    column = row = 0
    for symbol in message:
        plaintext[column] += symbol
        column += 1
        if (column == num_of_columns) or (
            column == num_of_columns - 1
            and row &gt;= num_of_rows - num_of_shaded_boxes
        ):
            column = 0
            row += 1
    return &#34;&#34;.join(plaintext)</code></pre>
</details>
</dd>
<dt id="denverapi.cipher.transposition_cipher.encrypt"><code class="name flex">
<span>def <span class="ident">encrypt</span></span>(<span>message: str, key: int)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def encrypt(message: str, key: int):
    # Each string in ciphertext represents a column in the grid:
    ciphertext = [&#34;&#34;] * key
    # Loop through each column in ciphertext:
    for column in range(key):
        current_index = column
        # Keep looping until current_index goes past the message length:
        while current_index &lt; len(message):
            # Place the character at current_index in message at the
            # end of the current column in the ciphertext list:
            ciphertext[column] += message[current_index]
            # Move current_index over:
            current_index += key
    # Convert the ciphertext list into a single string value and return it:
    return &#34;&#34;.join(ciphertext)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="denverapi.cipher.vigenere_cipher"><code class="flex name class">
<span>class <span class="ident">vigenere_cipher</span></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class vigenere_cipher:
    @staticmethod
    def encrypt(m: str, k: str):
        return _cvig_translate_message(k, m, &#34;e&#34;)

    @staticmethod
    def decrypt(m: str, k: str):
        return _cvig_translate_message(k, m, &#34;d&#34;)</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="denverapi.cipher.vigenere_cipher.decrypt"><code class="name flex">
<span>def <span class="ident">decrypt</span></span>(<span>m: str, k: str)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def decrypt(m: str, k: str):
    return _cvig_translate_message(k, m, &#34;d&#34;)</code></pre>
</details>
</dd>
<dt id="denverapi.cipher.vigenere_cipher.encrypt"><code class="name flex">
<span>def <span class="ident">encrypt</span></span>(<span>m: str, k: str)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def encrypt(m: str, k: str):
    return _cvig_translate_message(k, m, &#34;e&#34;)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="denverapi" href="index.html">denverapi</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="denverapi.cipher.affine_cipher" href="#denverapi.cipher.affine_cipher">affine_cipher</a></code></h4>
<ul class="">
<li><code><a title="denverapi.cipher.affine_cipher.decrypt" href="#denverapi.cipher.affine_cipher.decrypt">decrypt</a></code></li>
<li><code><a title="denverapi.cipher.affine_cipher.encrypt" href="#denverapi.cipher.affine_cipher.encrypt">encrypt</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="denverapi.cipher.basic" href="#denverapi.cipher.basic">basic</a></code></h4>
<ul class="">
<li><code><a title="denverapi.cipher.basic.decode" href="#denverapi.cipher.basic.decode">decode</a></code></li>
<li><code><a title="denverapi.cipher.basic.encode" href="#denverapi.cipher.basic.encode">encode</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="denverapi.cipher.caesar_cipher" href="#denverapi.cipher.caesar_cipher">caesar_cipher</a></code></h4>
<ul class="">
<li><code><a title="denverapi.cipher.caesar_cipher.decrypt" href="#denverapi.cipher.caesar_cipher.decrypt">decrypt</a></code></li>
<li><code><a title="denverapi.cipher.caesar_cipher.encrypt" href="#denverapi.cipher.caesar_cipher.encrypt">encrypt</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="denverapi.cipher.morse" href="#denverapi.cipher.morse">morse</a></code></h4>
<ul class="">
<li><code><a title="denverapi.cipher.morse.decode" href="#denverapi.cipher.morse.decode">decode</a></code></li>
<li><code><a title="denverapi.cipher.morse.encode" href="#denverapi.cipher.morse.encode">encode</a></code></li>
<li><code><a title="denverapi.cipher.morse.table" href="#denverapi.cipher.morse.table">table</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="denverapi.cipher.reverse_cipher" href="#denverapi.cipher.reverse_cipher">reverse_cipher</a></code></h4>
<ul class="">
<li><code><a title="denverapi.cipher.reverse_cipher.crypt" href="#denverapi.cipher.reverse_cipher.crypt">crypt</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="denverapi.cipher.substitution_cipher" href="#denverapi.cipher.substitution_cipher">substitution_cipher</a></code></h4>
<ul class="">
<li><code><a title="denverapi.cipher.substitution_cipher.decrypt" href="#denverapi.cipher.substitution_cipher.decrypt">decrypt</a></code></li>
<li><code><a title="denverapi.cipher.substitution_cipher.encrypt" href="#denverapi.cipher.substitution_cipher.encrypt">encrypt</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="denverapi.cipher.transposition_cipher" href="#denverapi.cipher.transposition_cipher">transposition_cipher</a></code></h4>
<ul class="">
<li><code><a title="denverapi.cipher.transposition_cipher.decrypt" href="#denverapi.cipher.transposition_cipher.decrypt">decrypt</a></code></li>
<li><code><a title="denverapi.cipher.transposition_cipher.encrypt" href="#denverapi.cipher.transposition_cipher.encrypt">encrypt</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="denverapi.cipher.vigenere_cipher" href="#denverapi.cipher.vigenere_cipher">vigenere_cipher</a></code></h4>
<ul class="">
<li><code><a title="denverapi.cipher.vigenere_cipher.decrypt" href="#denverapi.cipher.vigenere_cipher.decrypt">decrypt</a></code></li>
<li><code><a title="denverapi.cipher.vigenere_cipher.encrypt" href="#denverapi.cipher.vigenere_cipher.encrypt">encrypt</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>